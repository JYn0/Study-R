# R

08.13

**scalar**

factor

**vector**

matrix - 한가지 타입이 들어간다

**dataframe** - 다양한 타입이 들어간다



--------------



## 변수

##### 변수 이름 규칙

R의 변수명은 알파벳, 숫자, _(언더스코어), .(마침표)로 구성되며, -(하이픈)은 사용할 수 없다. 첫 글자는 알파벳 또는 .으로 시작해야 한다. 만약 .으로 시작한다면 . 뒤에는 숫자가 올 수 없다. 

##### 변숫값 할당

변수에 값을 할당할 때는 <-, <<- 또는 = 연산자를 사용한다.

```R
a <- c(1:10);
b <- mean(a);
print(a);		# 1  2  3  4  5  6  7  8  9 10
print(b)		# 5.5
> source('C:/rstudio/r1/r01.R')

a <- c(1,3,5);
b <- c(1:5);
c <- c(1,3,c(4:6));
print(c)		# 1 3 4 5 6
```

할당 연산자 중 =는 명령의 최상위 수준에서만 사용할 수 있는 반면 <-는 어느 곳에서나 사용할 수 있다. 따라서 함수 호출과 동시에 변수에 값을 할당하는 목적으로는 <-만 사용할 수 있다. 



## 스칼라

**스칼라** : R에서 데이터 타입의 기본은 벡터Vector다. 따라서 스칼라 데이터는 길이가 1인 벡터(즉, 길이가 1인 배열)와 같은 것으로 볼 수 있다.

**NA ** : R과 다른 언어의 가장 큰 차이 중 하나가 바로 NANot Available 상수다. NA는 데이터 값이 없음을 뜻한다. 변수에 NA 값이 저장되어 있는지는 is.na( ) 함수로 확인한다.

**NULL** :  NULL 객체를 뜻하며, 변수가 초기화되지 않았을 때 사용한다. 어떤 변수에 NULL이 저장되어 있는지는 is.null( )을 사용해 판단할 수 있다. NULL은 변숫값이 아직 미정인 상태를 표현하는 목적으로 사용한다.



```R
a <- 100;
b <- mean(a);
c <- NA;
d <- NULL;
print(is.na(c));	# TRUE
print(is.null(d));	# TRUE
print(a+c)			# NA

a <- 100;
b <- 200.98
c <- NA;
d <- NULL;
print(is.na(c));	# TRUE
print(is.null(d));	# TRUE
result <- 0;
if(is.na(c)){
  result <- a * 100;
}
print(result)		# 10000
```



### 팩터

**팩터**(Factor) : 범주형Categorical 데이터(자료)를 표현하기 위한 데이터 타입이다.

```R
> sex <- factor("m", c("m", "f"))

data <- factor("m",c("m","f"));
print(data);			# m
print(levels(data)[1]);	# "m"
print(levels(data)[2])	# "f"
Levels: m f

data <- factor("b",c("b","m","s"));
print(levels(data)[2])	# "m"
```

위 코드에서 sex에는 “m”이 저장되었고, 이 팩터가 담을 수 있는 값의 레벨은 “m”, “f”로 제한되었다



## 벡터

**벡터Vector** : 다른 프로그래밍 언어에서 흔히 접하는 배열의 개념으로, 한 가지 스칼라 데이터 타입의 데이터를 저장할 수 있다. 예를 들어, 숫자만 저장하는 배열, 문자열만 저장하는 배열이 벡터에 해당한다.

벡터는 c( )를 사용해 생성하고, names( )를 사용해 이름을 부여할 수 있다. 

벡터 데이터 접근

| x[n]  |  벡터 x의 n번째 요소. n은 숫자 또는 셀의 이름을 뜻하는 문자열   |
| ----- | :--------------------------------------: |
| x[-n] | 벡터 x에서 n번째 요소를 제외한 나머지. n은 숫자 또는 셀의 이름을 뜻하는 문자열 |

```R
score <- c(100,90,80)
names(score) <- c("lee", "kim", "han");
print(score)
# lee kim han 
# 100  90  80 

score <- c(100,90,80)
names(score) <- c("lee", "kim", "han");
print(score[1])
# lee
# 100

v1 <- c(1:10);
print(v1[-1])
# 2 3 4 5 6 7 8 9 10

a <- c(1:10)
print(a)			# 1  2  3  4  5  6  7  8  9 10
aa <- c(1,10)
print(aa)			# 1 10
b <- seq(1,10,3)
print(b)			# 1  4  7 10
c <- rep(1,times=5)
print(c)			# 1 1 1 1 1

a <- c(1:10)
print(a)			# 1  2  3  4  5  6  7  8  9 10
b <- seq(1,10,3)	# 1부터 10까지 3씩 증가
print(b)			# 1  4  7 10
c <- rep(1,times=5)	# 1을 5번 반복
print(c)			# 1 1 1 1 1

```



## 리스트

**리스트** :  ‘(키key, 값value)’ 형태의 데이터를 담는 연관 배열Associative Array이다. 벡터와 달리 <u> 값이 서로 다른 데이터 타입을 담을 수 있다.</u>



```R
a <- list(name=c("a","b","c","d"),score=c(90,100,80,30))
print(a)
# $name
# [1] "a" "b" "c" "d"
# $score
# [1]  90 100  80  30

# list에서 value값 꺼내기
print(a[1])
# $name
# [1] "a" "b" "c" "d"

# list에서 key값 꺼내기
print(a$name[1])
# [1] "a"

a <- list(s1=c(80,90,70,88),s2=c(90,100,80,30))
print(a)
# $s1
# [1] 80 90 70 88
# $s2
# [1]  90 100  80  30

#s1 avg
print(mean(a$s1))
#s2 avg
print(mean(a$s2))
#avg
print(mean(c(mean(a$s1),mean(a$s2))))

a <- list(s1=c(80,90,70,88),s2=c(90,100,80,30))
d1 <- mean(a$s1)
d2 <- mean(a$s2)
print(d1)				# 82
print(d2)				# 75
print(mean(c(d1,d2)))	# 78.5

d1 <- mean(a$s1[c(1,4)])
d2 <- mean(a$s2[c(1,3)])
print(d1) 				# 82
print(d2) 				# 90
```



## 행렬

R의 **행렬**(Matrix) : 행(로우), 열(컬럼)의 수가 지정된 구조다.  벡터와 마찬가지로 행렬에는 한 가지 유형의 스칼라만 저장할 수 있다.

```R
data <- c(1:9)
ma <- matrix(data,nrow=3)
print(ma)
#      [,1] [,2] [,3]
# [1,]    1    4    7
# [2,]    2    5    8
# [3,]    3    6    9

data <- c(1:9)
ma <- matrix(data,nrow=3)
rownames(ma) <- c("r1", "r2","r3")
colnames(ma) <- c("c1", "c2","c3")
print(ma)
#    c1 c2 c3
# r1  1  4  7
# r2  2  5  8
# r3  3  6  9
print(ma[2,3])			# 8
print(ma["r2","c3"])	# 8

ma2 <- ma[c(2,3),c(2,3)]
print(ma2)
#    c2 c3
# r2  5  8
# r3  6  9

ma <- matrix(c(1:6),nrow=3)
print(nrow(ma))		# 3
print(ncol(ma))		# 2
print(ma)
#      [,1] [,2]
# [1,]    1    4
# [2,]    2    5
# [3,]    3    6
```









